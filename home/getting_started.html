<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Getting Started :: Stackable Documentation</title>
    <link rel="canonical" href="https://docs.stackable.tech/home/getting_started.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../_/css/site.css">
    <script>var uiRootPath = '../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://docs.stackable.tech">Stackable Documentation</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="home" data-version="master">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Stackable Documentation</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="paths.html">Default Paths</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">ADRs</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Current</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/ADR001-choose_project_language.html">Use English as Documentation Language</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/ADR002-choose_repository_structure.html">Use Multiple Repositories instead of one Large Repository</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/ADR003-choose_review_mechanism.html">Use RTC as Review Mechanism for Changes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/ADR004-choose_agent_programming_language.html">Use Rust as programming language for the agent</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/ADR005-systemd_unit_file_location.html">Decide on handling and location of systemd unit files</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/ADR007-defined_reuse_of_k8s.html">Decide if Kubernetes Components Are to be Reused for Stackable</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/ADR008-decide_reuse_of_operators.html">Allow Reuse of Existing Kubernetes Operators</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/ADR009-selector_support.html">ADR009: Assigning Services to Nodes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/ADR010-command_pattern.html">ADR010: Expressing one-shot commands in a Kubernetes-native way</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/ADR011-directory_structure.html">ADR011: Directory Structure Used by Stackable Components on Managed Hosts</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Deprecated</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/deprecated/ADR006-choose_orchestrator_storage_backend.html">Use xxx as storage backend for the orchestrator</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Drafts</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adr/drafts/ADRx-choose_authorization_engine.html">Choose Authorization Engine</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Maturity Levels</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Components</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="maturity_levels/operators/operator_maturity_levels.html">Operator Maturity Levels</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="maturity_levels/operators/apache_kafka.html">Apache Kafka</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="maturity_levels/operators/apache_nifi.html">Apache NiFi</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="maturity_levels/operators/apache_spark.html">Apache Spark</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="maturity_levels/operators/apache_zookeeper.html">Apache ZooKeeper</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="maturity_levels/platform/platform_maturity_levels.html">Platform Maturity Levels</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="maturity_levels/platform/ML1.html">Maturity Level 1</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="maturity_levels/platform/ML2.html">Maturity Level 2</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="maturity_levels/platform/ML3.html">Maturity Level 3</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="maturity_levels/platform/ML4.html">Maturity Level 4</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="maturity_levels/platform/ML5.html">Maturity Level 5</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Stackable Documentation</span>
    <span class="version">master</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../agent/index.html">Stackable Agent</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../agent/index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="index.html">Stackable Documentation</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../kafka/index.html">Stackable Operator for Apache Kafka</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../kafka/index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../nifi/index.html">Stackable Operator for Apache NiFi</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../nifi/index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../spark/index.html">Stackable Operator for Apache Spark</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../spark/index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../zookeeper/index.html">Stackable Operator for Apache ZooKeeper</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../zookeeper/index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../monitoring/index.html">Stackable Operator for Monitoring and Metrics</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../monitoring/index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../opa/index.html">Stackable Operator for OpenPolicyAgent</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../opa/index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../regorule/index.html">Stackable Operator for OpenPolicyAgent Rego rules</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../regorule/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Stackable Documentation</a></li>
    <li><a href="getting_started.html">Getting Started</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/stackabletech/documentation/edit/main/modules/ROOT/pages/getting_started.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Getting Started</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>One of the best ways of getting started with a new platform is to try it out. Any big data platform has a lot of moving parts and getting some hands on keyboard time with it helps reinforce learning.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_about_this_guide"><a class="anchor" href="#_about_this_guide"></a>About this guide</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Firstly, let’s cover whether this Getting started guide is right for you. This is intended as a learning tool to discover more about Stackable, its deployment and architecture.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you just want to get up and running quickly there is a quickstart script that will install services on a single node available in the <a href="https://github.com/stackabletech/stackable-utils">stackable-utils</a> repository on GitHub.</p>
</li>
<li>
<p>If you want to build a production cluster then this is not for you. This tutorial is to familiarise you with the Stackable architecture and is not a guide for building robust clusters.</p>
</li>
<li>
<p>This is intended for use in a private network or lab; it doesn’t enable any security features such as authentication or encryption and should not be directly connected to the Internet. Be careful if you&#8217;re deploying in the cloud as your instances may default to using public IPs.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview"><a class="anchor" href="#_overview"></a>Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We’re going to build a small cluster in this tutorial, so the first thing we need is some machines to build the cluster on. Maybe you have some spare servers sitting around you can use but for most people running virtual machines makes more sense. If you’ve sufficient resources on your workstation you can run them on there, or launch cloud instances if you prefer. However you choose to deploy, we recommend running your cluster across multiple hosts since this is much closer to a typical deployment.</p>
</div>
<div class="paragraph">
<p>Stackable requires a Kubernetes control plane to manage the cluster and one or more worker nodes to run the services themselves. We’ll build a simple cluster with 3 services; Apache ZooKeeper, Apache Kafka and Apache NiFi. For simplicity, we will deploy an instance of each of these services onto 3 separate nodes.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/getting_started_arch.png" alt="High-level deployment architecture for Stackable" width="600"></span></p>
</div>
<div class="paragraph">
<p>Since this is a walkthrough on how to install Stackable and we’re not building a production cluster, we can be fairly frugal with our resources. We’ll be using Ubuntu 20.04 running in VirtualBox in this walkthrough and recommend that you do the same as this will help you follow the instructions in this guide. It is assumed that you will know how to perform systems administration tasks such as configuring virtual machines, setting the hostnames and configuring name resolution. The virtual machines will require internet access to download the software.</p>
</div>
<div class="paragraph">
<p>Below is a table for recommended sizing for this tutorial. Bear in mind that these sizings are not intended for operational clusters, but for the purpose of this tutorial. If you run any significant load through this cluster then you will almost certainly need to assign more memory and disk space.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Hostname</th>
<th class="tableblock halign-left valign-top">Minimum RAM</th>
<th class="tableblock halign-left valign-top">Minimum Disk Space</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controller node</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.stackable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 GB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Worker node 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">node1.stackable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20 GB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Worker node 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">node2.stackable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20 GB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Worker node 3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">node3.stackable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20 GB</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_installing_kubernetes"><a class="anchor" href="#_installing_kubernetes"></a>Installing Kubernetes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Stackable’s control plane is built around Kubernetes. We’ll be deploying services not as containers but as regular services controlled by systemd. Stackable Agent is a custom kubelet and bridges the worlds between Kubernetes and native deployment. For this walkthrough we’ll be using K3s, which offers a very quick and easy way to bootstrap your Kubernetes infrastructure. On your controller node run the following command as root to install K3s:</p>
</div>
<div class="paragraph">
<p><code>curl -sfL <a href="https://get.k3s.io" class="bare">https://get.k3s.io</a> | sh -</code></p>
</div>
<div class="paragraph">
<p>So long as your VM has an Internet connection it will download and automatically configure a simple Kubernetes environment.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>root@kubernetes:~# curl -sfL https://get.k3s.io | sh -
[INFO]  Finding release for channel stable
[INFO]  Using v1.21.3+k3s1 as release
[INFO]  Downloading hash https://github.com/k3s-io/k3s/releases/download/v1.21.3+k3s1/sha256sum-amd64.txt
[INFO]  Downloading binary https://github.com/k3s-io/k3s/releases/download/v1.21.3+k3s1/k3s
[INFO]  Verifying binary download
[INFO]  Installing k3s to /usr/local/bin/k3s
[INFO]  Creating /usr/local/bin/kubectl symlink to k3s
[INFO]  Creating /usr/local/bin/crictl symlink to k3s
[INFO]  Creating /usr/local/bin/ctr symlink to k3s
[INFO]  Creating killall script /usr/local/bin/k3s-killall.sh
[INFO]  Creating uninstall script /usr/local/bin/k3s-uninstall.sh
[INFO]  env: Creating environment file /etc/systemd/system/k3s.service.env
[INFO]  systemd: Creating service file /etc/systemd/system/k3s.service
[INFO]  systemd: Enabling k3s unit
Created symlink /etc/systemd/system/multi-user.target.wants/k3s.service → /etc/systemd/system/k3s.service.
[INFO]  systemd: Starting k3s</pre>
</div>
</div>
<div class="paragraph">
<p>To check if everything worked as expected you can use <code>kubectl cluster-info</code> to retrieve the cluster information.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>root@kubernetes:~# kubectl cluster-info
Kubernetes control plane is running at https://127.0.0.1:6443
CoreDNS is running at https://127.0.0.1:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
Metrics-server is running at https://127.0.0.1:6443/api/v1/namespaces/kube-system/services/https:metrics-server:/proxy</pre>
</div>
</div>
<div class="paragraph">
<p>Now that we have Kubernetes running on the controller node we need to distribute the configuration to the worker nodes. You’ll find a configuration file on your controller node in <code>/etc/rancher/k3s/k3s.yaml</code>. Edit this file and set the property named clusters&#8594;server to the address of your controller node (by default this is set to 127.0.0.1). Once you’ve done this you can distribute the file out to the cluster. Copy this file to <code>/root/.kube/config</code> on each of the worker nodes. One of the default locations for the Kubernetes configuration file is in the user&#8217;s home directory and the Stackable Agent will check here by default when running as root as required.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_installing_stackable"><a class="anchor" href="#_installing_stackable"></a>Installing Stackable</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_specify_a_stackable_repository_in_kubernetes"><a class="anchor" href="#_specify_a_stackable_repository_in_kubernetes"></a>Specify a Stackable Repository in Kubernetes</h3>
<div class="paragraph">
<p>Stackable downloads packages from repositories, which the agents need to know about. To avoid having to configure these repositories on every agent they are instead specified in Kubernetes and retrieved from there by the agent.</p>
</div>
<div class="paragraph">
<p>In order to allow creating a repository, you’ll have to create the CRD for repositories in your freshly installed Kubernetes cluster. The CRD looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: repositories.stable.stackable.de
spec:
  group: stable.stackable.de
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                repo_type:
                  type: string
                properties:
                  type: object
                  additionalProperties:
                    type: string
  scope: Namespaced
  names:
    plural: repositories
    singular: repository
    kind: Repository
    shortNames:
    - repo</pre>
</div>
</div>
<div class="paragraph">
<p>You can choose whatever way is most convenient for you to apply this CRD to your cluster. You can use <code>kubectl apply -f</code> to read the CRD from a file or from stdin as in this example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: repositories.stable.stackable.de
spec:
  group: stable.stackable.de
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                repo_type:
                  type: string
                properties:
                  type: object
                  additionalProperties:
                    type: string
  scope: Namespaced
  names:
    plural: repositories
    singular: repository
    kind: Repository
    shortNames:
    - repo
EOF</pre>
</div>
</div>
<div class="paragraph">
<p>You can either host your own repository or specify the Stackable public repository for convenience. The specification for our repository is shown below and can be applied with <code>kubectl</code> just like the definition above:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: "stable.stackable.de/v1"
kind: Repository
metadata:
  name: stackablepublic
spec:
  repo_type: StackableRepo
  properties:
    url: https://repo.stackable.tech/repository/packages/
EOF</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_installing_stackable_crds"><a class="anchor" href="#_installing_stackable_crds"></a>Installing Stackable CRDs</h3>
<div class="paragraph">
<p>Kubernetes uses custom resource descriptors or CRDs to define the resources that will be under its control. We firstly need to load the CRDs for the Stackable services before it will be able to deploy them to the cluster. We can do this using kubectl again, just as we did to install the CRD for the Stackable repository. Kubectl can read from stdin, so we’ll use cURL to download the CRDs we need and pipe them to kubectl.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>curl -s -S https://raw.githubusercontent.com/stackabletech/zookeeper-operator/main/deploy/crd/zookeepercluster.crd.yaml | kubectl apply -f -
curl -s -S https://raw.githubusercontent.com/stackabletech/kafka-operator/main/deploy/crd/kafkacluster.crd.yaml | kubectl apply -f -
curl -s -S https://raw.githubusercontent.com/stackabletech/agent/main/deploy/crd/repository.crd.yaml | kubectl apply -f -
curl -s -S https://raw.githubusercontent.com/stackabletech/nifi-operator/main/deploy/crd/nificluster.crd.yaml | kubectl apply -f -</pre>
</div>
</div>
<div class="paragraph">
<p>Check the output for each command. You should see a message that the CRD was successfully created.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>root@kubernetes:~# curl -s -S https://raw.githubusercontent.com/stackabletech/zookeeper-operator/main/deploy/crd/zookeepercluster.crd.yaml | kubectl apply -f -
customresourcedefinition.apiextensions.k8s.io/zookeeperclusters.zookeeper.stackable.tech created</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_the_stackable_os_package_repository"><a class="anchor" href="#_configuring_the_stackable_os_package_repository"></a>Configuring the Stackable OS package repository</h3>
<div class="paragraph">
<p>You will need to configure the Stackable OS package repository on the worker nodes. We’ll also take the opportunity to install OpenJDK Java 11 as well as this will be required by the Stackable services we will be running.</p>
</div>
<div class="sect3">
<h4 id="_debian_and_ubuntu"><a class="anchor" href="#_debian_and_ubuntu"></a>Debian and Ubuntu</h4>
<div class="literalblock">
<div class="content">
<pre>apt-get install gnupg openjdk-11-jdk curl
apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 16dd12f5c7a6d76a
echo "deb https://repo.stackable.tech/repository/deb-dev buster main" &gt; /etc/apt/sources.list.d/stackable.list
apt-get update</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_red_hat_and_centos"><a class="anchor" href="#_red_hat_and_centos"></a>Red Hat and CentOS</h4>
<div class="literalblock">
<div class="content">
<pre>/usr/bin/yum -y install gnupg2 java-11-openjdk curl
/usr/bin/curl -s "https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0xce45c7a0a3e41385acd4358916dd12f5c7a6d76a" &gt; /etc/pki/rpm-gpg/RPM-GPG-KEY-stackable
/usr/bin/rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-stackable
echo "[stackable]
name=Stackable ${REPO_TYPE} repo
baseurl=${REPO_URL}
enabled=1
gpgcheck=0" &gt; /etc/yum.repos.d/stackable.repo
/usr/bin/yum clean all</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_installing_stackable_operators"><a class="anchor" href="#_installing_stackable_operators"></a>Installing Stackable Operators</h3>
<div class="paragraph">
<p>The Stackable operators are components that translate the service definitions deployed via Kubernetes into deploy services on the worker nodes. These can be installed on any node that has access to the Kubernetes control plane. In this example we will install them on the controller node. Remember to install the Stackable OS package repo before installing the operators as described above.</p>
</div>
<div class="sect3">
<h4 id="_debian_and_ubuntu_2"><a class="anchor" href="#_debian_and_ubuntu_2"></a>Debian and Ubuntu</h4>
<div class="literalblock">
<div class="content">
<pre>apt-get install stackable-zookeeper-operator \
stackable-kafka-operator \
stackable-nifi-operator</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_red_hat_and_centos_2"><a class="anchor" href="#_red_hat_and_centos_2"></a>Red Hat and CentOS</h4>
<div class="literalblock">
<div class="content">
<pre>yum install stackable-zookeeper-operator-server \
stackable-kafka-operator-server \
stackable-nifi-operator-server</pre>
</div>
</div>
<div class="paragraph">
<p>You can then enable the services using systemctl:</p>
</div>
</div>
<div class="sect3">
<h4 id="_apache_zookeeper"><a class="anchor" href="#_apache_zookeeper"></a>Apache ZooKeeper</h4>
<div class="literalblock">
<div class="content">
<pre>systemctl start stackable-zookeeper-operator-server
systemctl enable stackable-zookeeper-operator-server</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_apache_kafka"><a class="anchor" href="#_apache_kafka"></a>Apache Kafka</h4>
<div class="literalblock">
<div class="content">
<pre>systemctl start stackable-kafka-operator-server
systemctl enable stackable-kafka-operator-server</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_apache_nifi"><a class="anchor" href="#_apache_nifi"></a>Apache NiFi</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There’s an issue with the NiFi operator not looking in the correct place for its configuration properties file. Workaround using <code>sudo ln -s /etc/stackable/nifi-operator /deploy</code> prior to starting the Apache NiFi operator.
</td>
</tr>
</table>
</div>
<div class="literalblock">
<div class="content">
<pre>systemctl start stackable-nifi-operator-server
systemctl enable stackable-nifi-operator-server</pre>
</div>
</div>
<div class="paragraph">
<p>You can use <code>systemctl status &lt;service-name&gt;</code> to check whether the services have started correctly. If they do not start then look in /var/log/syslog for any clues as to why.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_installing_stackable_agent"><a class="anchor" href="#_installing_stackable_agent"></a>Installing Stackable Agent</h3>
<div class="paragraph">
<p>On each of the worker nodes you’ll need to install Stackable Agent, which runs a custom kubelet that can be used to launch non-containerised applications using systemd. If this doesn’t make a lot of sense to you, don’t worry. What this means is that you can run regular Linux services using the Kubernetes control plane. This makes sense for example if you wish to run a hybrid deployment with a mix of bare metal and containerised services and manage them all with one framework.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Don’t install the agent onto the controller node as it is already has the K3s kubelet running and this would cause a clash. Stackable Agent should only be deployed on the worker nodes.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_debian_and_ubuntu_3"><a class="anchor" href="#_debian_and_ubuntu_3"></a>Debian and Ubuntu</h4>
<div class="literalblock">
<div class="content">
<pre>apt-get install stackable-agent</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_red_hat_and_centos_3"><a class="anchor" href="#_red_hat_and_centos_3"></a>Red Hat and CentOS</h4>
<div class="literalblock">
<div class="content">
<pre>yum install stackable-agent</pre>
</div>
</div>
<div class="paragraph">
<p>Once installed, the agent configuration file is created in '/etc/stackable-agent/agent.conf'. If you have provided a kubeconfig for the root user in /root/.kube/config then the agent will use this, or you may specify where the config should be read from This can be done by adding a systemd drop-in file.. Put the following content in /usr/lib/systemd/system/stackable-agent.service.d/kubeconfig.conf:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[Service]
Environment="KUBECONFIG=/path/to/kubeconfig"</pre>
</div>
</div>
<div class="paragraph">
<p>In most circumstances the Stackable Agent configuration file will be mostly empty. You can rely on the default settings in most cases.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_starting_the_agent"><a class="anchor" href="#_starting_the_agent"></a>Starting the Agent</h3>
<div class="paragraph">
<p>The agent can be started like any regular systemd service</p>
</div>
<div class="literalblock">
<div class="content">
<pre>systemctl start stackable-agent</pre>
</div>
</div>
<div class="paragraph">
<p>To enable it to be started at every boot:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>systemctl enable stackable-agent</pre>
</div>
</div>
<div class="paragraph">
<p>During the first start of the agent, it will perform some bootstrapping tasks, most notably it will generate a keypair and request a signed certificate from Kubernetes. You’ll see a message similar to this in /var/log/syslog.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Aug 10 12:53:48 node1 stackable-agent[5208]: [2021-08-10T12:53:48Z INFO  stackable_agent] Successfully bootstrapped TLS certificate: TLS certificate requires manual approval. Run kubectl certificate approve node1.stackable-tls</pre>
</div>
</div>
<div class="paragraph">
<p>You will need to manually approve that certificate requests created by the agents before the agent can start. You can do this by running <code>kubectl certificate approve &lt;agent-fqdn&gt;-tls</code> on the controller node after starting the agent.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>root@kubernetes:~# kubectl certificate approve node1.stackable-tls
certificatesigningrequest.certificates.k8s.io/node1.stackable-tls approved</pre>
</div>
</div>
<div class="paragraph">
<p>Once the nodes have been registered and had their certificates signed they will appear in your Kubernetes environment. You can run <code>kubectl get nodes</code> to retrieve the state of all the nodes in your cluster. You should see all of the worker nodes reporting their state as Ready.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>root@kubernetes:~# kubectl get nodes
NAME               	STATUS   ROLES              	AGE 	VERSION
kubernetes.stackable   Ready	control-plane,master	27h 	v1.21.3+k3s1
node2.stackable    	Ready	&lt;none&gt;             	7s  	0.7.0
node3.stackable    	Ready	&lt;none&gt;             	5s  	0.7.0
node1.stackable    	Ready	&lt;none&gt;             	3m43s	0.7.0</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_deploying_stackable_services"><a class="anchor" href="#_deploying_stackable_services"></a>Deploying Stackable Services</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At this point you’ve successfully deployed the Stackable node infrastructure and are ready to deploy services to the cluster. To do this we provide service descriptions to Kubernetes for each of the services we wish to deploy.</p>
</div>
<div class="sect2">
<h3 id="_apache_zookeeper_2"><a class="anchor" href="#_apache_zookeeper_2"></a>Apache ZooKeeper</h3>
<div class="paragraph">
<p>We will deploy 3 Apache ZooKeeper instances to our cluster. This is a fairly typical deployment to provide resilience against the failure of a single ZooKeeper node.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>kubectl apply -f - &lt;&lt;EOF
---
apiVersion: zookeeper.stackable.tech/v1alpha1
kind: ZookeeperCluster
metadata:
  name: simple
spec:
  version: 3.5.8
  servers:
    roleGroups:
      default:
        selector:
          matchLabels:
            kubernetes.io/arch: stackable-linux
        replicas: 3
        config:
          adminPort: 12000
          metricsPort: 9505
EOF</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_apache_kafka_2"><a class="anchor" href="#_apache_kafka_2"></a>Apache Kafka</h3>
<div class="paragraph">
<p>We will deploy 3 Apache Kafka brokers, another typical deployment pattern for Kafka clusters. Note that Kafka depends on the ZooKeeper service and the zookeeperReference property below points to the namespace and name we gave to the ZooKeeper service deployed previously.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>kubectl apply -f - &lt;&lt;EOF
---
apiVersion: kafka.stackable.tech/v1alpha1
kind: KafkaCluster
metadata:
  name: simple
spec:
  version:
    kafka_version: 2.8.0
  zookeeperReference:
    namespace: default
    name: simple
  brokers:
    roleGroups:
      default:
        selector:
          matchLabels:
            kubernetes.io/arch: stackable-linux
        replicas: 3
        config:
          logDirs: "/tmp/kafka-logs"
          metricsPort: 96</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_apache_nifi_2"><a class="anchor" href="#_apache_nifi_2"></a>Apache NiFi</h3>
<div class="paragraph">
<p>We will deploy 3 Apache servers NiFi. This might seem over the top for a tutorial cluster, but it&#8217;s worth pointing out that the operator will cluster the 3 NiFi servers for us automatically.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>kubectl apply -f - &lt;&lt;EOF
---
apiVersion: nifi.stackable.tech/v1alpha1
kind: NifiCluster
metadata:
  name: simple
spec:
  metricsPort: 8428
  version: "1.13.2"
  zookeeperReference:
    name: simple
    namespace: default
    chroot: /nifi
  nodes:
    roleGroups:
      default:
        selector:
          matchLabels:
            kubernetes.io/arch: stackable-linux
        replicas: 3
        config:
          nifiWebHttpPort: 10000
          nifiClusterNodeProtocolPort: 10443
          nifiClusterLoadBalancePort: 6342
EOF</pre>
</div>
</div>
<div class="paragraph">
<p>You can check the status of the services using <code>kubectl get pods</code>. This will retrieve the status of all pods running in the default namespace.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>root@kubernetes:~# kubectl get pods
NAME                                    READY   STATUS       RESTARTS   AGE
zookeeper-simple-default-server-node3   1/1     Running      0          6m32s
nifi-simple-default-node-node3          1/1     Running      0          6m32s
kafka-simple-default-broker-node3       1/1     Running      0          6m32s
zookeeper-simple-default-server-node2   1/1     Running      0          6m32s
kafka-simple-default-broker-node2       1/1     Running      0          6m32s
nifi-simple-default-node-node2          1/1     Running      0          6m32s
kafka-simple-default-broker-node1       1/1     Running      0          6m32s
nifi-simple-default-node-node1          1/1     Running      0          6m32s
zookeeper-simple-default-server-node1   1/1     Running      0          6m32s</pre>
</div>
</div>
<div class="paragraph">
<p>Since this is the first time that each of these services has been deployed to these nodes the Stackable Agent needs to download the software from the Stackable repository. It may take a few minutes to complete the download and deploy the services.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_your_cluster"><a class="anchor" href="#_testing_your_cluster"></a>Testing your cluster</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If all has gone well then you will have successfully deployed a Stackable cluster and used it to start three services that should now be ready for you.</p>
</div>
<div class="sect2">
<h3 id="_apache_zookeeper_3"><a class="anchor" href="#_apache_zookeeper_3"></a>Apache ZooKeeper</h3>
<div class="paragraph">
<p>Log onto one of your worker nodes and run the ZooKeeper CLI shell. Stackable stores the service software in /opt/stackable/packages, so you may wish to add this to your PATH environment variable.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>PATH=$PATH:/opt/stackable/packages/zookeeper-3.5.8/apache-zookeeper-3.5.8-bin/bin
zkCli.sh</pre>
</div>
</div>
<div class="paragraph">
<p>The shell should connect automatically to the ZooKeeper server running on localhost. You can run the <code>ls /</code> command to see the list of znodes in the root path, which should include those created by Apache Kafka and Apache NiFi.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[zk: localhost:2181(CONNECTED) 0] ls /
[admin, brokers, cluster, config, consumers, controller, controller_epoch, feature, isr_change_notification, latest_producer_id_block, log_dir_event_notification, nifi, zookeeper]</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_apache_kafka_3"><a class="anchor" href="#_apache_kafka_3"></a>Apache Kafka</h3>
<div class="paragraph">
<p>To test Kafka we&#8217;ll use the tool <code>kafkacat</code>.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>sudo apt install kafkacat</pre>
</div>
</div>
<div class="paragraph">
<p>With <code>kafkacat</code> installed we can log into one of the worker nodes query the metadata on the broker running on localhost.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>user@node1:~$ kafkacat -b localhost -L
 Metadata for all topics (from broker -1: localhost:9092/bootstrap):
  3 brokers:
   broker 1001 at node2.stackable:9092 (controller)
   broker 1003 at node1.stackable:9092
   broker 1002 at node3.stackable:9092
  0 topics:</pre>
</div>
</div>
<div class="paragraph">
<p>We should see 3 brokers listed, showing that Stackable has successfully deployed the brokers as a cluster.</p>
</div>
</div>
<div class="sect2">
<h3 id="_apache_nifi_3"><a class="anchor" href="#_apache_nifi_3"></a>Apache NiFi</h3>
<div class="paragraph">
<p>Apache NiFi provides a web interface and the easiest way to test it is to view this in a web browser. Browse to the address of one of your worker nodes on port 8080 e.f. <a href="http://node1.stackable:8080/nifi" class="bare">http://node1.stackable:8080/nifi</a> and you should see the NiFi Canvas.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/nifi_menu.png" alt="The Apache NiFi web interface"></span></p>
</div>
<div class="paragraph">
<p>Click on the menu and select Cluster as illustrated in the screenshot above and you&#8217;ll see that the 3 NiFi servers have been deployed as a cluster.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="/nifi_cluster.png" alt="The Apache NiFi Cluster status screen"></span></p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
</footer>
<script src="../_/js/site.js"></script>
<script async src="../_/js/vendor/highlight.js"></script>
  </body>
</html>
